services: #definisce i servizi da avviare, nel nostro caso server e client
  
  database:
    image: postgres:latest
    container_name: dieti-estates-db
    env_file:
      - backend/.env
    ports:
      - "5433:5432"
    volumes:
      - db-data:/var/lib/postgresql
    networks:
      - dieti-estates-network
    restart: unless-stopped
  
  server: 
    build: #definisce come costruire l'immagine del server
      context: ./backend
      dockerfile: Dockerfile
    container_name: dieti-estates-server
    ports:
      - "8080:8080" # Mappa la porta 8080 del container alla porta 8080 della macchina host
    env_file:
      - backend/.env
    networks:
      - dieti-estates-network # Rete per la comunicazione tra container
    depends_on:
      - database
    restart: unless-stopped # Riavvia il server se si arresta in modo anomalo
    dns:
      - 8.8.8.8
      - 8.8.4.4

  client:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      # build args will be read from the environment or from an env_file;
      # avoid embedding secrets directly in compose. If you need build-time
      # values, pass them as build-args via the CLI or CI pipeline.
      args:
        GOOGLE_API_KEY: ${GOOGLE_API_KEY}
        GEOAPIFY_TOKEN: ${GEOAPIFY_TOKEN}
        API_BASE_URL: ${API_BASE_URL}
    container_name: dieti-estates-client
    # Load runtime env vars (including secrets) from frontend/.env
    env_file:
      - frontend/.env
    environment:
      # For local compose deployment we want the client to call the backend
      # container directly using the service name and internal port.
      - API_BASE_URL=http://server:8080
      
    networks:
      - dieti-estates-network
    depends_on:
      - server
    ports:
      - "4200:80"
    restart: unless-stopped
    dns:
      - 8.8.8.8
      - 8.8.4.4

networks:
  dieti-estates-network:
    driver: bridge

volumes:
  db-data: {}